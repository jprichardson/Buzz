#!/usr/bin/env node

var spawn = require('child_process').spawn
  , program = require('commander')
  , colors = require('colors')
  , ON_DEATH = require('death')({uncaughtException: true}) //trigger on uncaughtException as well

program.version(require('../package.json').version)
  .option('-t, --time [time]', 'Kill program after time in (seconds).', Math.pow(2,42)*1000) //default to killing your program in 140k years :)
  .option('-d, --delay [time]', 'Restart program after delay in (seconds).', 250)
  .usage("[options] cmd args")
  .on('--help', function() {
    console.log('  Examples:')
    console.log('')
    console.log('    $ buzz -t 3600 your-long-running-script.sh --input-file records.txt')
    console.log('')
  })

//cmd is either 2nd,4th,6th arg
var maybeArgs = [process.argv[2], process.argv[4], process.argv[6]]
var n = maybeArgs.reduce(function(last, item, i) {
  if (item && item.indexOf('-') < 0)
    return (i+1)*2
  else
    return last
},-1)

if (n < 0) {
  program.parse(process.argv) //program name won't show up then
  console.log(colors.red("\n  Did you pass the command? Here's the help:"))
  return program.help()
}

var execName = process.argv[n]
var execArgs = process.argv.splice(n)
execArgs.shift() //get rid of execName

console.dir(process.argv)
console.dir(execArgs)

program.parse(process.argv)

console.log(program.time)
console.log(program.delay)
return


var args = process.argv
  , rekillTimeSecs = parseInt(args[2], 10)
  , execName = ''
  , killInterval = null
  , proc = null
  , quitCountThreshold = 5
  , quitTimeThreshold = 10000
  , startupDelay = 250

var ondeathCount = 0
ON_DEATH(function(signal, err) {
  ondeathCount += 1
  if (ondeathCount === 1) {
    proc.removeListener('exit', exitCallback)
    if (killInterval) clearInterval(killInterval)
    killCallback()
    
    setTimeout(function() { //give child process 10 seconds to cleanup
        process.exit()
    }, 10*1000)

    if (signal === 'SIGINT')
      console.log("Press ^C again to terminate")
  } else if (ondeathCount > 1) { //presumably the user really wants to quit
    console.error("Received multiple death threats. Buzz died.")
    process.exit(1)
  }
})

main()

function main (arguments) {
  if (rekillTimeSecs.toString() !== 'NaN') {
    execName = args[3]
    args.splice(0,4)
    killInterval = setInterval(killCallback, rekillTimeSecs * 1000)
  } else {
    execName = args[2]
    args.splice(0,3)
  }

  //console.log(execName)
  //console.dir(args)
  startItUp()
}

function startItUp() {
  console.log(colors.blue("\nStarting " + execName + " " + args.join(' ') + "..."))
  proc = spawn(execName, args);
  proc.stdout.on('data', stdoutCallback);
  proc.stderr.on('data', stderrCallback);
  proc.on('exit', exitCallback);
}

function stderrCallback(data) {
  console.log(colors.red(data.toString('utf8').trim()))
}

function stdoutCallback(data) {
  console.log(data.toString('utf8').trim());
}

var quitCounter = 0
function exitCallback(code) {
  console.log(colors.red("<=== EXIT: DIED or KILLED ===>"))
  setTimeout(function() {
    startItUp()
    if (killInterval) {
      clearInterval(killInterval)
      killInterval = setInterval(killCallback, rekillTimeSecs * 1000)
    }
  },startupDelay)

  quitCounter += 1
  if (quitCounter === 1) { //first time dying, time threshold
    setTimeout(function() {
      quitCounter = 0
    }, quitTimeThreshold)
  } else if (quitCounter >= quitCountThreshold) {
    console.error("Quit too soon too often.")
    process.exit(100)
  } 
}

function killCallback() {
  console.log(colors.blue("Killling " + proc.pid + "..."))
  proc.kill('SIGTERM');
}




