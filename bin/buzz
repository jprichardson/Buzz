#!/usr/bin/env node

var spawn = require('child_process').spawn
  , program = require('commander')
  , colors = require('colors')
  , cmd = require('../lib/cmd')
  , ON_DEATH = require('death')({uncaughtException: false}) //trigger on uncaughtException as well

program.version(require('../package.json').version)
  .option('-t, --time [time]', 'Kill program after time in (seconds).', Math.pow(2,42)) //default to killing your program in 140k years :)
  .option('-d, --delay [time]', 'Restart program after delay in (seconds).', 0.250)
  .usage("[options] cmd args")
  .on('--help', function() {
    console.log('  Examples:')
    console.log('')
    console.log('    $ buzz -t 3600 your-long-running-script.sh --input-file records.txt')
    console.log('')
  })

var argO = cmd.splitArgs(process.argv)
if (argO.n < 0) {
  program.parse(process.argv) //program name won't show up then
  console.log(colors.red("\n  Did you pass the command? Here's the help:"))
  return program.help()
}

var execName = argO.execName
var execArgs = argO.execArgs

program.parse(process.argv)


var args = process.argv
  , rekillTimeSecs = +program.time//parseInt(args[2], 10)
  , killInterval = setInterval(killCallback, rekillTimeSecs * 1000)
  , proc = null
  , quitCountThreshold = 5
  , quitTimeThreshold = 10000
  , ondeathCount = 0
  , startupDelay = +program.delay

ON_DEATH(function(signal, err) {
  ondeathCount += 1
  if (ondeathCount === 1) {
    proc.removeListener('exit', exitCallback)
    if (killInterval) clearInterval(killInterval)
    killCallback()
    
    setTimeout(function() { //give child process 10 seconds to cleanup
        process.exit()
    }, 10*1000)

    if (signal === 'SIGINT')
      console.log("Press ^C again to terminate")
  } else if (ondeathCount > 1) { //presumably the user really wants to quit
    console.error("Received multiple death threats. Buzz died.")
    process.exit(1)
  }
})

startItUp()
function startItUp() {
  console.log(colors.blue("\nStarting " + execName + " " + execArgs.join(' ') + "..."))
  
  proc = spawn(execName, execArgs)
  proc.stdout.on('data', stdoutCallback);
  proc.stderr.on('data', stderrCallback);
  proc.on('exit', exitCallback);
}

function stderrCallback(data) {
  console.log(colors.red(data.toString('utf8').trim()))
}

function stdoutCallback(data) {
  console.log(data.toString('utf8').trim());
}

var quitCounter = 0
function exitCallback(code) {
  console.log(colors.red("<=== EXIT: DIED or KILLED ===>"))
  setTimeout(function() {
    startItUp()
    if (killInterval) {
      clearInterval(killInterval)
      killInterval = setInterval(killCallback, rekillTimeSecs * 1000)
    }
  },startupDelay*1000)

  quitCounter += 1
  if (quitCounter === 1) { //first time dying, time threshold
    setTimeout(function() {
      quitCounter = 0
    }, quitTimeThreshold)
  } else if (quitCounter >= quitCountThreshold) {
    console.error("Quit too soon too often.")
    process.exit(100)
  } 
}

function killCallback() {
  console.log(colors.blue("Killling " + proc.pid + "..."))
  proc.kill('SIGTERM');
}




